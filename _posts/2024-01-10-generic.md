---
published: true
layout: single
title:  "[Java] 제네릭 상한제한(*? extends T*) / 하한제한(*? super T*)"
excerpt: ""
categories:
  - Java
tags:
  - Java
use_math: true
---

# 상한제한(? extends T)
`?` 자리에 올 수 있는 인스턴스는 **T 이거나 T를 상속받는 서브 클래스**다.
```java
public class Generic {

  static class A {}
  static class B1 extends A {}
  static class B2 extends A {}
  static class C extends B1 {}
  static class D extends B1 {}
  /*
   *   Object
   *     |
   *     A
   *    / \
   *   B1 B2
   *   | \
   *   C  D
   */

  public static void main(String[] args) {
    //    m1(new ArrayList<Object>()); // 컴파일 오류!
    //    m1(new ArrayList<A>()); // 컴파일 오류!
    m1(new ArrayList<B1>()); // OK
    //    m1(new ArrayList<B2>()); // 컴파일 오류!
    m1(new ArrayList<C>()); // OK
    m1(new ArrayList<D>()); // OK
  }

  static void m1(ArrayList<? extends B1> list) {
    //        list.add(new B1()); // 컴파일 오류!
    //        list.add(new C()); // 컴파일 오류!
    //        list.add(new D()); // 컴파일 오류!

    Object obj1 = list.get(0);
    B1 obj2 = list.get(0);
    //    C obj3 = list.get(0); // 컴파일 오류!
    //    D obj4 = list.get(0); // 컴파일 오류!
  }
}
```
위 코드에서 m1 메소드는 B1의 서브클래스를 담고 있는 `ArrayList`를 인자로 받을 수 있다. 따라서 `ArrayList<B1>()`, `ArrayList<C>()`, `ArrayList<D>()`가 올 수 있다.
이는 변수에 인스턴스를 할당하는 과정을 생각해보면 자연스럽다. 

문제는 메소드 내에서 저 `list` 로 넘어온 인스턴스를 사용할때다. **제네릭 문법은 컴파일 시 `Object`로 전부 치환된다.** 
그렇다는 말은 인스턴스의 레퍼런스를 확실히 하려면 명시적 형변환이 필요하다.
```java

```



# 하한제한(? super T)
`?` 자리에 올 수 있는 인스턴스는 **T 이거나 T의 부모클래스**다.
```java
public class Generic {

  static class A {}
  static class B1 extends A {}
  static class B2 extends A {}
  static class C extends B1 {}
  /*
   *   Object
   *     |
   *     A
   *    / \
   *   B1 B2
   *   |
   *   C
   */

  public static void main(String[] args) {
    m1(new ArrayList<Object>()); // OK
    m1(new ArrayList<A>()); // OK
    m1(new ArrayList<B1>()); // OK 
    //    m1(new ArrayList<B2>()); // 컴파일 오류!
    //    m1(new ArrayList<C>()); // 컴파일 오류! 
  }

  static void m1(ArrayList<? super B1> list) {
    //    list.add(new Object()); // 컴파일 오류!
    //    list.add(new A());
    list.add(new B1()); // OK
    list.add(new C()); // OK

    Object obj1 = list.get(0);

    // 컴파일 오류!
    // - 넘어오는 ArrayList의 항목 타입이 B1 일 수도 있고, 그 상위 일 수 도 있다.
    //
    //    B1 obj2 = list.get(0); 
    //    C obj3 = list.get(0); 
  }
}
```