---
published: true
layout: single
title: "[PS] 99클럽 코테 스터디 29일차 TIL (Longest Increasing Subsequence)"
excerpt: "항해99 스터디"
categories:
  - PS
tags:
  - [ 'PS', '이분탐색', '99클럽', '코딩테스트준비', '항해99', 'TIL' ]
use_math: true
---


![img_3.png](https://github.com/zhtmr/static-files-for-posting/blob/main/static-files-for-posting/20240722/99club_TIL_thumbnail/%EA%B8%B0%EB%B3%B8%ED%98%951_java.png?raw=true)


# 문제
[문제 링크](https://leetcode.com/problems/longest-increasing-subsequence/)

![img_3.png](https://github.com/zhtmr/static-files-for-posting/blob/main/static-files-for-posting/20240819/ex.png?raw=true){: .align-center}

# 설명
어떤 수열이 주어질때 수열 내에서 **가장 긴 증가하는 부분수열(LIS)**의 길이를 반환하는 문제
# 풀이 (DP)

```java
class Solution {
  public int lengthOfLIS(int[] nums) {
    int[] dp = new int[nums.length];
    Arrays.fill(dp, 1);

    int maxLen = 1;
    for (int i = 1; i < nums.length; i++) {
      for (int j = 0; j < i; j++) {
        if (nums[j] < nums[i]) {
          dp[i] = Math.max(dp[i], dp[j] + 1);
        }
      }
      maxLen = Math.max(maxLen, dp[i]);

    }
    return maxLen;
  }
}
```

# 풀이 (이분탐색)

```java
class Solution {
  public int lengthOfLIS(int[] nums) {
    int[] lis = new int[nums.length];
    int length = 0;

    for (int num : nums) {
      int pos = Arrays.binarySearch(lis, 0, length, num);
      if (pos < 0) {
        pos = -(pos + 1);
      }
      lis[pos] = num;
      if (pos == length) {
        length++;
      }
    }
    return length;
  }
}
```