---
published: true
layout: single
title: "[PS] 99클럽 코테 스터디 10일차 TIL (이중우선순위큐)"
excerpt: "항해99 스터디"
categories:
  - PS
tags:
  - [ 'PS', '99클럽', '코딩테스트준비', '항해99', 'TIL' ]
use_math: true
---

![img_3.png](https://github.com/zhtmr/static-files-for-posting/blob/main/static-files-for-posting/20240722/99club_TIL_thumbnail/%EA%B8%B0%EB%B3%B8%ED%98%951_java.png?raw=true)

# 문제

[문제 링크](https://school.programmers.co.kr/learn/courses/30/lessons/42628)

# 풀이
```java
class Solution {
  public int[] solution(String[] operations) {

    PriorityQueue<Integer> minHeap = new PriorityQueue<>();
    PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Comparator.reverseOrder());
    for (String command : operations) {
      if (command.contains("I")) {
        maxHeap.add(Integer.valueOf(command.split(" ")[1]));
        minHeap.add(Integer.valueOf(command.split(" ")[1]));
      } else if (command.equals("D 1")) {
        minHeap.remove(maxHeap.poll());
      } else {
        maxHeap.remove(minHeap.poll());

      }
    }

    int[] result = new int[2];
    result[0] = maxHeap.peek() == null ? 0 : maxHeap.peek();
    result[1] = minHeap.peek() == null ? 0 : minHeap.peek();
    return result;
  }
}
```
문제에서 요구하는 것은 최소값 또는 최대값을 뽑는 하나의 경우가 아니라, 조건에 따라 우선순위 큐에서 최대값을 뽑던지, 최소값을 뽑던지 해야 한다.
`PriorityQueue` 에는 최소값과 최대값을 선별하는 메소드가 없고, 단지 생성 시 전달해 주는 파라미터에 따라 큐 안의 요소를 정렬한다.

만약 파라미터 없이 생성하게 되면 `PriorityQueue` 는 *자연 순서(natural ordering)* 를 따른다. 즉, `PriorityQueue` 에 저장된 객체들은 기본적으로 객체의 `Comparable` 인터페이스의 `compareTo` 메소드에 의해 정렬된다.
숫자는 오름차순으로, 문자열은 사전순으로 정렬된다.

```java
public int compareTo(Integer anotherInteger) {
    return this.value - anotherInteger.value;
}
```

![img_5.png](https://github.com/zhtmr/static-files-for-posting/blob/main/static-files-for-posting/20240731/natural_ordering.png?raw=true){: .align-center}
*PriorityQueue 는 기본적으로 오름차순 정렬*

```java
PriorityQueue<Integer> minHeap = new PriorityQueue<>();
minHeap.poll();     // 우선순위 큐 안에 들어있는 값 중 제일 작은 값 반환.

PriorityQueue<Integer> maxHeap = new PriorityQueue<>(Comparator.reverseOrder());
maxHeap.poll();     // 우선순위 큐 안에 들어있는 값 중 제일 큰 값 반환.
```

코드와 같이 최대값과 최소값을 관리하기 위해 최대힙과 최소힙을 만들어 줬다. 값을 저장시에 양쪽에 저장 후, 값을 뺄때 최소값이면 최소힙에서 빼주고 최대값이면 최대힙에서 빼주면 된다.
그리고 값을 넣을때 양쪽에 같이 넣었기 때문에 한쪽 힙에서 빠진 값은 다른쪽 힙에서도 빼줘야 서로 동기화가 된다.

```java
// 최대값을 제거 후 최소힙에서 해당 값 제거
minHeap.remove(maxHeap.poll());

// 최소값을 제거 후 최대힙에서 해당 값 제거
maxHeap.remove(minHeap.poll());
```

## 문제점
**PriorityQueue의 remove 연산 시간 복잡도**

해당 코드는 `remove()` 로 삭제하는 부분이 문제인데, `PriorityQueue` 가 힙의 구조(완전이진트리)를 가지고 있는 것과 별개로 삭제할 요소를 탐색해야 하기 때문에 전체를 순회해야 한다.
힙의 목적인 최대 / 최소 값을 리턴하는 `poll()` 을 사용하는 것에서 끝나는 것이 아니라, for 문 안에서 `remove()` 를 호출하고 있다. 
operations 배열에서 "I" 커맨드가 많아질 수록(힙에 넣는 작업이 증가할수록) remove 시 탐색해야 하는 수도 늘어난다.


## 개선


## TreeMap 을 사용한 풀이

![](https://github.com/zhtmr/static-files-for-posting/blob/main/static-files-for-posting/20240731/binary-search-tree-sorted-array-animation.gif?raw=true){: .align-center}
*(출처: https://www.mathwarehouse.com/programming/gifs/binary-search-tree.php#binary-search-tree-insertion-node)*

`PriorityQueue` 은 양쪽에서 값을 뺄 수가 없어, 최대힙과 최소힙을 두개 만들고 서로 동기화 시키는 작업이 필요했다. 그리고 특정 값을 탐색하는데 O(n) 의 시간복잡도가 걸린다.
그에 반해 `TreeMap` 는 이진탐색트리의 구조를 갖고 있어, 값 삽입시 기존 노드와 비교해 더 큰 값은 오른쪽에, 더 작은 값은 왼쪽에 저장하는 규칙이 있다. 결국 이 문제는 최대/최소값이 모두 필요한 문제이기 때문에 우선순위큐 보단 트리맵을 쓰는 것이 구현의 복잡도가 낮아 보인다.

더 자세히 살펴보자면 `TreeMap` 는 이진탐색트리를 개선한 `Red-Black Tree` 형태를 가지고 있다. 
기존 이진탐색트리의 단점은 트리에 편향된 값만 들어올 경우 한쪽으로 값이 쏠리게 된다. 
그러면 결국 탐색하는 시간이 트리의 깊이에 비례하기 때문에 최악의 경우 트리의 최대 깊이까지 탐색해야 한다.

`Red-Black Tree` 는 다음과 같은 속성을 갖고 있다.
1. 모든 노드는 레드 아니면 블랙이다.
2. 루트 노드는 블랙이다.
3. 모든 NIL(leaf) 노드는 블랙이다.
4. 레드 노드는 레드 노드를 자식으로 가질 수 없다. 따라서...
   - 모든 레드 노드의 부모는 블랙이다.
   - 레드 노드는 연속으로 존재(Double red)할 수 없다.
5. 임의의 한 노드에서 NIL 노드까지 도달하는 모든 경로에는 항상 같은 수의 블랙 노드가 있다.

트리에 값을 삽입 후 항상 저 특성에 따라서 트리의 구조를 재조정 하다보면 모양이 균형을 이룬다는 것이다.
예를 들어 현재 트리에 다음과 같이 값이 들어가 있다고 해보자.

![img_5.png](https://github.com/zhtmr/static-files-for-posting/blob/main/static-files-for-posting/20240731/img_5.png?raw=true){: .align-center}


여기에 이진탐색트리의 조건을 만족하면서, 레드-블랙 트리의 속성을 만족시키려면 삽입되는 노드는 빨간색으로 시작해야 한다.  

![img_6.png](https://github.com/zhtmr/static-files-for-posting/blob/main/static-files-for-posting/20240731/img_6.png?raw=true){: .align-center}


레드-블랙 트리의 속성을 유지하기 위해 오른쪽으로 회전 후 색을 다시 변경해주면

최종적으로 다음과 같은 모습이 된다.

![img_8.png](https://github.com/zhtmr/static-files-for-posting/blob/main/static-files-for-posting/20240731/img_8.png?raw=true){: .align-center}



![](https://upload.wikimedia.org/wikipedia/commons/thumb/4/41/Red-black_tree_example_with_NIL.svg/632px-Red-black_tree_example_with_NIL.svg.png){: .align-center}
*(출처 : https://en.wikipedia.org/wiki/Red%E2%80%93black_tree)*


레드-블랙 트리 시뮬레이션은 [여기](https://ds2-iiith.vlabs.ac.in/exp/red-black-tree/red-black-tree-oprations/simulation/redblack.html)서 가능하다.


```java
class Solution {
    public int[] solution(String[] operations) {
        
        TreeMap<Integer, Integer> map = new TreeMap<>();

        for (String command : operations) {
          if (command.contains("I")) {
            String num = command.split(" ")[1];
            map.put(Integer.valueOf(num), map.getOrDefault(Integer.valueOf(num), 0) + 1);
          } else if (command.equals("D 1")) {
            if (map.isEmpty()) {
              continue;
            }
            Integer max = map.lastKey();
            if (map.get(max) == 1) {
              map.remove(max);
            } else {
              map.put(max, map.get(max) - 1);
            }
          } else {
            if (map.isEmpty()) {
              continue;
            }
            Integer min = map.firstKey();
            if (map.get(min) == 1) {
              map.remove(min);
            } else {
              map.put(min, map.get(min) - 1);
            }
          }
        }


        int[] result = new int[2];
        if (map.isEmpty()) {
          result[0] = 0;
          result[1] = 0;
        } else {
          result[0] = map.lastKey();
          result[1] = map.firstKey();
        }
        return result;
    }
}
```
이진탐색 트리의 일종이기 때문에 가장 왼쪽값이 제일 작고, 가장 오른쪽 값이 제일 크다. 따라서 루트 노드에서부터 가장 왼쪽 값을 반환하는 메소드와 가장 오른쪽 값을 반환하는 메소드를 제공하고 있다.
![img_5.png](https://github.com/zhtmr/static-files-for-posting/blob/main/static-files-for-posting/20240731/treemap.png?raw=true){: .align-center}

