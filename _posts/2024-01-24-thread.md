---
published: true
layout: single
title:  "[CS] 동시성 제어(Concurrency control)"
excerpt: ""
categories:
  - CS
tags:
  - ['Java','CS']
use_math: true
---

> - 멀티스레딩 환경에서 race condition 이 일어나는 이유를 알아본다.
> - race condition 을 해결하기 위한 concurrency control 들을 알아본다.
> - thread pool 에 대해 알아보고, java 에서 지원하는 스레드 라이프사이클 관련 api 를 알아본다.

# 동시성 제어를 하지 않으면?
동시성에 대해 알아보기 전에 먼저 아래 코드의 결과를 예상해보자. 
```java
public class Test {
  static class A {
    int value;
    void plus() {
      while (value < 1000_0000) {
        value += 1;
      }
      System.out.println("value = " + value);
    }
  }

  static class Worker extends Thread {
    A a;

    public Worker(A a) {
      this.a = a;
    }

    @Override
    public void run() {
      a.plus();
    }
  }

  public static void main(String[] args) {
    A a = new A();
    Worker worker1 = new Worker(a);
    Worker worker2 = new Worker(a);
    Worker worker3 = new Worker(a);
    Worker worker4 = new Worker(a);
    worker1.start();
    worker2.start();
    worker3.start();
    worker4.start();
  }
}
```
클래스 `A` 는 1000만이 될 때까지 더하는 `plus()` 메소드를 가지고 있다. 
이 작업을 수행할 스레드들을 만들고 실행 실행시키면 각자 1000만까지 더하고 종료될 것이라 

현재 여러 스레드가 하나의 계좌에 접근하는 상황에서 Account 클래스의 `balance -= money` 부분을 잘 생각해봐야 한다.
만약 

![](https://github.com/zhtmr/static-files-for-posting/blob/main/20240124/race_condition.png?raw=true){: .align-center}
*실행 도중에 context switching 발생한 경우*

![](https://github.com/zhtmr/static-files-for-posting/blob/main/20240124/thread_processes.jpg?raw=true){: .align-center}
*스레드는 프로세스의 Heap 영역을 공유한다*

즉, 컨텍스트 스위칭때문에 작업의 순서를 보장할 수 없는 것이다.
비동기 처리 시 공유 자원에 대한 접근 전략이 필요하다.

## Context switching


## Race condition


## 임계영역(Critical section)




## mutex

## semaphore

## spinlock

## monitor




스레드 동시성 제어와 데이터베이스 동시성 제어는 서로 다른 두 가지 개념이지만 일관성, 격리 및 정확성을 보장하기 위해 리소스에 대한 동시 액세스를 관리한다는 공통 목표를 공유합니다. 
이 두 가지 유형의 동시성 제어 방법을 비교해 보겠습니다.




## Thread 와 DB 의 동시성 제어 차이

Thread 는 Context Switching 이 원인이고, DB 는 각 Transaction 이 원인이다. 따라서 
요약하면, 스레드 동시성 제어는 단일 애플리케이션이나 프로세스 내에서 동시 액세스를 관리하는 데 중점을 두는 반면, 
데이터베이스 동시성 제어는 다중 사용자, 영구 스토리지 환경에서 일관성과 격리를 보장하는 작업을 다룹니다.


## 비동기 프로그래밍이 복잡하고 어려운 이유
비즈니스 로직에 대한 이해가 선행되어야 하고, 런타임 시점에 어떤식으로 프로그램이 동작할지 예측할 수 있어야 하기 때문.

## Executors

## Future

## Future vs Promise
